{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, inject, Optional, SkipSelf, ElementRef, KeyValueDiffers, Renderer2, input, signal, effect, Component, ChangeDetectionStrategy, makeEnvironmentProviders, NgModule } from '@angular/core';\nimport { of, throwError } from 'rxjs';\nimport { map, tap, catchError, finalize, share } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nconst _c0 = [\"*\"];\nclass SvgLoader {}\nlet SvgHttpLoader = /*#__PURE__*/(() => {\n  class SvgHttpLoader extends SvgLoader {\n    constructor(http) {\n      super();\n      this.http = http;\n    }\n    getSvg(url) {\n      return this.http.get(url, {\n        responseType: 'text'\n      });\n    }\n    static #_ = this.ɵfac = function SvgHttpLoader_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SvgHttpLoader)(i0.ɵɵinject(i1.HttpClient));\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: SvgHttpLoader,\n      factory: SvgHttpLoader.ɵfac\n    });\n  }\n  return SvgHttpLoader;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst SERVER_URL = new InjectionToken('SERVER_URL');\nlet SvgIconRegistryService = /*#__PURE__*/(() => {\n  class SvgIconRegistryService {\n    constructor() {\n      this.loader = inject(SvgLoader);\n      this.serverUrl = inject(SERVER_URL, {\n        optional: true\n      });\n      this.document = inject(DOCUMENT);\n      this.iconsByUrl = new Map();\n      this.iconsLoadingByUrl = new Map();\n    }\n    /** Add a SVG to the registry by passing a name and the SVG. */\n    addSvg(name, data) {\n      if (!this.iconsByUrl.has(name)) {\n        const div = this.document.createElement('DIV');\n        div.innerHTML = data;\n        const svg = div.querySelector('svg');\n        this.iconsByUrl.set(name, svg);\n      }\n    }\n    /** Load a SVG to the registry from a URL. */\n    loadSvg(url, name = url) {\n      // not sure if there should be a possibility to use name for server usage\n      // so overriding it for now if provided\n      // maybe should separate functionality for url and name use-cases\n      if (this.serverUrl && url.match(/^(http(s)?):/) === null) {\n        url = this.serverUrl + url;\n        name = url;\n      }\n      if (this.iconsByUrl.has(name)) {\n        return of(this.iconsByUrl.get(name));\n      } else if (this.iconsLoadingByUrl.has(name)) {\n        return this.iconsLoadingByUrl.get(name);\n      }\n      const o = this.loader.getSvg(url).pipe(map(svg => {\n        const div = this.document.createElement('DIV');\n        div.innerHTML = svg;\n        return div.querySelector('svg');\n      }), tap(svg => this.iconsByUrl.set(name, svg)), catchError(err => {\n        console.error(err);\n        return throwError(err);\n      }), finalize(() => this.iconsLoadingByUrl.delete(name)), share());\n      this.iconsLoadingByUrl.set(name, o);\n      return o;\n    }\n    /** Get loaded SVG from registry by name. (also works by url because of blended map) */\n    getSvgByName(name) {\n      if (this.iconsByUrl.has(name)) {\n        return of(this.iconsByUrl.get(name));\n      } else if (this.iconsLoadingByUrl.has(name)) {\n        return this.iconsLoadingByUrl.get(name);\n      }\n      return throwError(`No svg with name '${name}' has been loaded`);\n    }\n    /** Remove a SVG from the registry by URL (or name). */\n    unloadSvg(url) {\n      if (this.iconsByUrl.has(url)) {\n        this.iconsByUrl.delete(url);\n      }\n    }\n    static #_ = this.ɵfac = function SvgIconRegistryService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SvgIconRegistryService)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: SvgIconRegistryService,\n      factory: SvgIconRegistryService.ɵfac\n    });\n  }\n  return SvgIconRegistryService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction SVG_ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry) {\n  return parentRegistry || new SvgIconRegistryService();\n}\nconst SVG_ICON_REGISTRY_PROVIDER = {\n  provide: SvgIconRegistryService,\n  deps: [[new Optional(), new SkipSelf(), SvgIconRegistryService]],\n  useFactory: SVG_ICON_REGISTRY_PROVIDER_FACTORY\n};\nclass SvgIconHelper {\n  constructor() {\n    this.loaded = false;\n  }\n}\nlet SvgIconComponent = /*#__PURE__*/(() => {\n  class SvgIconComponent {\n    constructor() {\n      this.element = inject(ElementRef);\n      this.differs = inject(KeyValueDiffers);\n      this.renderer = inject(Renderer2);\n      this.iconReg = inject(SvgIconRegistryService);\n      this.src = input();\n      this.name = input();\n      this.stretch = input(false);\n      this.applyClass = input(false);\n      this.svgClass = input();\n      this.klass = input(undefined, {\n        alias: 'class'\n      });\n      this.viewBox = input();\n      this.svgAriaLabel = input();\n      this.svg = signal(0);\n      // Adapted from ngStyle (see:  angular/packages/common/src/directives/ng_style.ts)\n      this.svgStyle = input();\n      this.helper = new SvgIconHelper();\n      // Watch for src or name changes\n      effect(() => {\n        if (this.src() || this.name()) {\n          this.destroy();\n          this.init(this.src(), this.name());\n        }\n      }, {\n        allowSignalWrites: true\n      });\n      // Watch for viewBox changes\n      effect(() => {\n        const viewBox = this.viewBox();\n        if (!this.svg()) return;\n        this.updateViewBox(viewBox);\n      });\n      // Watch for style changes\n      effect(() => {\n        const values = this.svgStyle() || {};\n        if (!this.svg()) return;\n        this.applyChanges(this.helper.differ.diff(values));\n      });\n      // Watch for applyClass changes\n      effect(() => {\n        const _ = this.svg();\n        if (this.applyClass()) {\n          this.setClass(this.elemSvg, null, this.klass());\n        } else {\n          this.setClass(this.elemSvg, this.klass(), null);\n        }\n      });\n      // Watch for svgClass changes\n      let previousSvgClass;\n      effect(() => {\n        const _ = this.svg();\n        this.setClass(this.elemSvg, previousSvgClass, this.svgClass());\n        previousSvgClass = this.svgClass();\n      });\n      // Watch for klass changes\n      let previousKlass;\n      effect(() => {\n        const _ = this.svg();\n        const elem = this.element.nativeElement;\n        this.setClass(elem, previousKlass, this.klass());\n        this.setClass(this.elemSvg, previousKlass, this.applyClass() ? this.klass() : null);\n        previousKlass = this.klass();\n      });\n      // Watch for svgAriaLabel changes\n      effect(() => {\n        const _ = this.svg();\n        this.doAria(this.svgAriaLabel());\n      });\n      // Watch for stretch changes\n      effect(() => {\n        const _ = this.svg();\n        this.stylize(this.stretch());\n      });\n    }\n    ngOnDestroy() {\n      this.destroy();\n    }\n    get elemSvg() {\n      return this.element.nativeElement.firstChild;\n    }\n    init(src, name) {\n      if (src && name) {\n        const svgObs = this.iconReg.loadSvg(src, name);\n        if (svgObs) {\n          this.helper.icnSub = svgObs.subscribe(svg => this.initSvg(svg));\n        }\n      } else if (name) {\n        const svgObs = this.iconReg.getSvgByName(name);\n        if (svgObs) {\n          this.helper.icnSub = svgObs.subscribe(svg => this.initSvg(svg));\n        }\n      } else if (src) {\n        const svgObs = this.iconReg.loadSvg(src);\n        if (svgObs) {\n          this.helper.icnSub = svgObs.subscribe(svg => this.initSvg(svg));\n        }\n      } else {\n        this.element.nativeElement.innerHTML = '';\n        this.svg.set(0);\n      }\n    }\n    initSvg(svg) {\n      if (!this.helper.loaded && svg) {\n        this.setSvg(svg);\n      }\n    }\n    destroy() {\n      this.helper.icnSub?.unsubscribe();\n      this.helper = new SvgIconHelper();\n      // initialize differ with empty object\n      this.helper.differ = this.differs.find({}).create();\n    }\n    setSvg(svg) {\n      if (!this.helper.loaded && svg) {\n        this.helper.svg = svg;\n        const icon = svg.cloneNode(true);\n        const elem = this.element.nativeElement;\n        elem.innerHTML = '';\n        this.renderer.appendChild(elem, icon);\n        this.helper.loaded = true;\n        this.copyNgContentAttribute(elem, icon);\n        this.svg.update(x => x + 1);\n      }\n    }\n    updateViewBox(viewBox) {\n      if (viewBox) {\n        const icon = this.elemSvg;\n        if (viewBox === 'auto') {\n          // Attempt to convert height & width to a viewBox.\n          const w = icon.getAttribute('width');\n          const h = icon.getAttribute('height');\n          if (h && w) {\n            const vb = `0 0 ${w} ${h}`;\n            this.renderer.setAttribute(icon, 'viewBox', vb);\n            this.renderer.removeAttribute(icon, 'width');\n            this.renderer.removeAttribute(icon, 'height');\n          }\n        } else if (viewBox !== '') {\n          this.renderer.setAttribute(icon, 'viewBox', viewBox);\n          this.renderer.removeAttribute(icon, 'width');\n          this.renderer.removeAttribute(icon, 'height');\n        }\n      }\n    }\n    copyNgContentAttribute(hostElem, icon) {\n      const attributes = hostElem.attributes;\n      const len = attributes.length;\n      for (let i = 0; i < len; i += 1) {\n        const attribute = attributes.item(i);\n        if (attribute && attribute.name.startsWith('_ngcontent')) {\n          this.setNgContentAttribute(icon, attribute.name);\n          break;\n        }\n      }\n    }\n    setNgContentAttribute(parent, attributeName) {\n      this.renderer.setAttribute(parent, attributeName, '');\n      const len = parent.childNodes.length;\n      for (let i = 0; i < len; i += 1) {\n        const child = parent.childNodes[i];\n        if (child instanceof Element) {\n          this.setNgContentAttribute(child, attributeName);\n        }\n      }\n    }\n    stylize(stretch) {\n      if (this.helper.svg) {\n        const svg = this.element.nativeElement.firstChild;\n        if (stretch === true) {\n          this.renderer.setAttribute(svg, 'preserveAspectRatio', 'none');\n        } else if (stretch === false) {\n          this.renderer.removeAttribute(svg, 'preserveAspectRatio');\n        }\n      }\n    }\n    applyChanges(changes) {\n      if (!changes) return;\n      changes.forEachRemovedItem(record => this.setStyle(record.key, null));\n      changes.forEachAddedItem(record => this.setStyle(record.key, record.currentValue));\n      changes.forEachChangedItem(record => this.setStyle(record.key, record.currentValue));\n    }\n    setStyle(nameAndUnit, value) {\n      const [name, unit] = nameAndUnit.split('.');\n      value = value !== null && unit ? `${value}${unit}` : value;\n      const svg = this.elemSvg;\n      if (value !== null) {\n        this.renderer.setStyle(svg, name, value);\n      } else {\n        this.renderer.removeStyle(svg, name);\n      }\n    }\n    setClass(target, previous, current) {\n      if (target) {\n        if (previous) {\n          const klasses = (Array.isArray(previous) ? previous : previous.split(' ')).filter(klass => klass);\n          for (const k of klasses) {\n            this.renderer.removeClass(target, k);\n          }\n        }\n        if (current) {\n          const klasses = (Array.isArray(current) ? current : current.split(' ')).filter(klass => klass);\n          for (const k of klasses) {\n            this.renderer.addClass(target, k);\n          }\n        }\n      }\n    }\n    doAria(label) {\n      const svg = this.element.nativeElement.firstChild;\n      // If there is not a svgAriaLabel and the SVG has an arial-label, then do not override\n      // the SVG's aria-label.\n      if (svg && !(label === undefined && svg.hasAttribute('aria-label'))) {\n        if (label === '') {\n          this.renderer.setAttribute(svg, 'aria-hidden', 'true');\n          this.renderer.removeAttribute(svg, 'aria-label');\n        } else {\n          this.renderer.removeAttribute(svg, 'aria-hidden');\n          this.renderer.setAttribute(svg, 'aria-label', label);\n        }\n      }\n    }\n    static #_ = this.ɵfac = function SvgIconComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SvgIconComponent)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: SvgIconComponent,\n      selectors: [[\"svg-icon\"]],\n      inputs: {\n        src: [1, \"src\"],\n        name: [1, \"name\"],\n        stretch: [1, \"stretch\"],\n        applyClass: [1, \"applyClass\"],\n        svgClass: [1, \"svgClass\"],\n        klass: [1, \"class\", \"klass\"],\n        viewBox: [1, \"viewBox\"],\n        svgAriaLabel: [1, \"svgAriaLabel\"],\n        svgStyle: [1, \"svgStyle\"]\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      ngContentSelectors: _c0,\n      decls: 1,\n      vars: 0,\n      template: function SvgIconComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return SvgIconComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction provideAngularSvgIcon(config = {}) {\n  return makeEnvironmentProviders([SVG_ICON_REGISTRY_PROVIDER, config.loader || {\n    provide: SvgLoader,\n    useClass: SvgHttpLoader\n  }]);\n}\nlet AngularSvgIconModule = /*#__PURE__*/(() => {\n  class AngularSvgIconModule {\n    static forRoot(config = {}) {\n      return {\n        ngModule: AngularSvgIconModule,\n        providers: [SVG_ICON_REGISTRY_PROVIDER, config.loader || {\n          provide: SvgLoader,\n          useClass: SvgHttpLoader\n        }]\n      };\n    }\n    static #_ = this.ɵfac = function AngularSvgIconModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AngularSvgIconModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: AngularSvgIconModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return AngularSvgIconModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularSvgIconModule, SERVER_URL, SVG_ICON_REGISTRY_PROVIDER, SVG_ICON_REGISTRY_PROVIDER_FACTORY, SvgHttpLoader, SvgIconComponent, SvgIconRegistryService, SvgLoader, provideAngularSvgIcon };\n//# sourceMappingURL=angular-svg-icon.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}